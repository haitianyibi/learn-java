[TOC]

# java简介

c语言、c++语言都是编译成二进制文件，由计算机直接执行，称编译型语言。python、ruby等解释型语言由解释器直接加载源码然后运行，而java将源码编译成.class字节码，类似于抽象的CPU指令，针对不同平台编写虚拟机，虚拟机加载字节码并执行，形成一次编写处处运行的效果。

java EE \java SE\java ME即企业版、标准版、micro版

JSR规范\JCP组织\RI参考现实\TCK兼容性测试套件

IDE是集成开发环境：Integrated Development Environment 

参考(https://www.liaoxuefeng.com/)

参考(https://www.w3cschool.cn/java/)

## 一、java环境设置

### 1.下载安装JavaJDK

<https://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html>

jdk是开发工具

jre仅是运行环境

### 2.设置环境变量

JAVA_HOME指向JDK安装目录

classpath指向默认字节码位置，当前位置"."

PATH指向JDK安装目录下的bin目录%JAVA_HOME%\bin;

bin目录下的工具:

* java：即 JVM
* javac：java编译器将.java源文件转化为.class字节码文件
* jar：用于把一类的.class文件打包成一个.jar文件
* jdb：java调试器，用于开发阶段的运行调试

### 3.第一个java程序

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

一个公开的类叫hello,大小敏感，{}里是类的定义，一个公开的静态方法叫main，()里为方法参数，参数类型String[],参数名args，返回类型为void即空，每行代码；分号结束System类的.out方法的.println方法传入参数“hello，world!”。

一个java源码只能定义一个public类型的class,并且class名要和文件名完全一致。


java文件中有多个类，且没有public类，那么文件名任意，编译的.class文件也对应有多个（JDK8）


main方法是java程序的入口，总是从main方法开始执行代码。

java缩进不是必须的

保存文件名必须和public类名相同，大小写敏感，文件类型.java

```javac  类名.java```

编译，在当前文件夹下生成.class文件

```java 类名```

运行，不需要文件类型后缀

或直接

```java 类名.java```

JVM会自动编译并运行文件

这是Java 11新增的一个功能，它可以直接运行一个单文件源码！

需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。

![image-20200103212014828](Java.assets/image-20200103212014828.png)

[出现编码GBK不可映射字符](https://jingyan.baidu.com/article/e3c78d649a56233c4c85f502.html)

因为代码中含有中文，包括注释，系统默认编码格式GBK，中文字符代码格式UNICODE，

notepad++编译器具有自动转码功能。

为文件指定编码格式

javac -encoding UTF-8 类名.java

[出现需要class,interface、enum](https://blog.csdn.net/a66731167/article/details/81286537)

![image-20200103212127750](Java.assets/image-20200103212127750.png)

重新保存文件，编码格式改为ANSI



##  二、Java基础

### 1.Java的注释

* 单行注释

//

* 多行注释（不可以嵌套使用）

/*



*/

* JavaDoc注释方式（以/**开头,写在类和方法定义处，用于自动创建文档）

/**

*

*

*/

javadoc可以添加标签

<p>、<code>、@author、@deprecated、@param、@see、@since、@return
javadoc -d 文件夹名称 -author -version HelloWorld.java



### 2.标识符

用户可以起名的标识，如类名，变量名、方法名， 区分大小写。英文字母、$美元符号、_下划线开头，加上数字可以作为标识符的元素，但是数字不能作为标识符开头。无限长度的unicode编码，使用完整的单词，而不要使用隐含的缩写

java关键字、保留字即不能用作标识符，类名使用驼峰式写法，普通变量和方法名使用小驼峰式写法、常量全大写、

必须先声明变量后使用，

四种变量

1.实例变量(非静态字段)

实例变量的值对于每一个实例都是唯一的。

2.类变量(静态字段)

无论实例化多少次，都存在一个副本应用于所有对象。，添加final修饰符将无法修改。

3.局部变量

变量位于方法体的左大括号和右大括号之间，仅对于声明他们的方法可见。

4.参数

方法的小括号之间。*参数*是指方法声明中的变量列表

### 3.关键字

Java使用关键字标识功能，产生语法语义。  关键字不做变量名、类名。

关键字：

**abstract	class extends	implement	null	strictfp	true	assert	const		false	import	package	super	 try	boolean	continue	final	instanceof	private	switch	void	break	default	finally	int	protected	synchronized	volatile	byte	do	float	interface	public	this	while	case	double	for	long	return	throw	catch	else	goto	native	short	throws	char	enum	if	new	static	transient**



### 4.字面值（常量）

类似c语言中的字符常量。  1、a、屏幕、3.14。

定义变量时使用final修饰符，编译器就将该变量看做常量，后面尝试修改此常量值编译器会报错

常量名习惯全部大写。





### 5.变量

变量本质上是内存的一块空间，还具有可见性/生存周期。变量包含数据类型、名称、字面值。  

所有变量必须具有类型。

java变量分两种，基本类型变量+引用类型变量

要求首字母小写，后面每个字母首字母大写  (小驼峰写法)

变量的类型决定了变量可能的取值范围和可能执行的操作。

编译器会赋初值，但是不会为局部变量赋初始值。

变量声明：int a;int b,c;  

变量同时声明和赋值:int a=1;

字面值的数据类型要和变量的数据类型一致。  

变量的值可以修改多次。而变量的空间大小的不变的，空间位置改变，即修改了引用的指针。  

 变量需要赋值才能使用，声明变量本质只是生成了引用标签，空间未申请，赋值后才实际申请了空间。

变量作用域最小化{}，减少重名变量。

给变量赋值时jvm给新值一个空间并将变量标签重新指向新变量空间，不是将旧变量空间替换值。

允许创建赋值链

允许动态初始化

成员变量

方法局部变量

静态变量（类变量）

### 6.数据类型

如int、short、float、char、String。  

不同数据类型可以指示编译器申请空间和限制变量的类型。  

原始数据类型int 、short、 char、long、float、double、String、boolean、byte、

基本数据类型是CPU可以直接进行运算的类型：

* 整数型byte、short、int、long
* 浮点类型float、double
* 字符类型char
* 布尔类型boolean

`_`数字文字中数字之间的任何位置都可以出现任意数量的下划线字符。

枚举类型

数据类型的自动转换与强制转换

布尔类型的true和false不等于1和0

byte是有符号的8位类型-128~127

short是有符号的16位类型-32768~32767

int是有符号的 32位类型，byte和short在表达式中时自动转化为int

long是有符号64位，1l、1L

八进制010

十六进制0x10

float32位宽

double64位宽，1.4E5F、2e3f

浮点类型支持科学计数法

双值常数，支持+00正无穷 -00负无穷 +0.0 -0.0	NaN

java使用unicode表示字符 \u5465

char为16位0~65536，单引号，可以和整数类型运算



### 7.运算符的优先级

后缀：a++、a--

一元元算符：++a、--a、+a、-a、~取反、！非

乘法：*、/、%

加法：+、-

移位：<<、>>、>>>

关系：<、>、<=、>=、instanceof

相等：==、！=

按位与：&

按位异或：^

按位或：|

逻辑与：&& 

逻辑或：||

三元：表达式?表达式1:表达式2

分配：=、+=、-=、*=、/=、%=、&=、^=、|=、<<=、>>=、>>>=

算术运算符的操作数必须是数字类型，也可以对char类型使用，但是不可以对boolean类型使用

算术运算符、布尔逻辑运算符、关系运算符、三元运算符、按位运算符

Java三元运算符基本上是简单的if语句的简写形式。

### 8.表达式

由变量、运算符和方法的调用，计算结果为单值。

语句：表达式语句、赋值语句、增量语句、方法调用语句、对象创建语句、声明语句、控制流语句。

###  9.数组 

* 基本类型数组
* 引用类型数组

### 10.输入和输出

import 导入java.util.Scanner类

* print()
* println()
* printf()+占位符
* Scanner scanner =new Scanner(System.in)创建scanner对象
* scanner.nextLine()读取一行输入获取字符串
* scanner.nextInt()读取一行输入获取整数

### 11.if判断

if(条件trun则执行){

}

if(){

}else if(){

}

if(){

}else

dosomething

### 12.switch多重选择

### 13.while循环

while(条件){

}

do{

}while(条件);



### 14.for循环

for(初始;条件;变化){

}

允许多个变量控制循环for(int i=0,j=n;i<j;i++,j--){

}

初始，变化可以为空，条件不能空for(;!aboolean;){}

for循环可以嵌套

Java for each循环对序列元素迭代，不使用循环计数器

for(String s:arr){//arr为string数组、类型要与数组类型兼容

}

for(int a[]:arr){//arr为二维数组

}



### 15.break和continue

break；循环终止，多重循环时只会终止内层循环

switch分支的break会跳出switch语句。分支终止

continue完成这次循环，内层

continue可以使用标签lable

lable名:语句

continue lable名；



### 16.转义字符

\\'	\\"	\\\	\r	\f	\t	\b	\n

八进制\123	十六进制unicode字符\u061

### 17.枚举

​        Weekday day = Weekday.SUN;

enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}

`enum`定义的类型就是`class`，只不过它有以下几个特点：

- 定义的`enum`类型总是继承自`java.lang.Enum`，且无法被继承；
- 只能定义出`enum`的实例，而无法通过`new`操作符创建`enum`的实例；
- 定义的每个实例都是引用类型的唯一实例；
- 可以将`enum`类型用于`switch`语句。

## 三、java初级

### 1.类

class本身就是一种数据类型

类主体用{}括起即类的定义，类变量、实例变量、方法、构造函数

大驼峰写法

构造函数，类似方法声明，但必须使用本类名且无返回类型

构造函数可以有多个，但是参数列表（参数的数量和类型）不能相同，

编译器会自动为没有构造函数的类提供无参的默认构造函数，默认构造函数将调用超类的无参构造函数，若超类没有无参构造函数编译器将报错，

构造函数可以使用访问修饰符

构造方法重载

方法首字母为动词，小驼峰写法。有返回类型

调用方法overload时，使用的参数必须在类型和顺序上与声明的参数匹配。

方法重载，区别方法的不同不依靠方法名，依靠参数（参数个数、类型、顺序），在同一类中，功能相似时方法名可以相同，功能不同时方法名尽可能不同。方法不能重复。方法重载和方法名和参数有关，和返回类型、修饰符无关。

可以使用任何数据类型作为方法和构造函数的参数，包括原始数据类型和引用数据类型（数组，对象）。参数数量可以无限，当不确定使用多少参数时可以使用*varargs*的构造方式，在最后的参数类型上加上...三个点和参数名，就可以使用该参数0个到无限个。方法内部将该参数视为数组，用数组下标调用传入的参数。

方法返回到调用它时的代码

- 完成方法中的所有语句，
- 达到`return`声明，或
- 引发异常（稍后会发现），

以先发生者为准。

如果尝试从声明的方法返回值`void`，则会出现编译器错误。

返回值的数据类型必须与方法声明的返回类型相匹配

java是面向对象的语言，一个程序的基本单位是class

在类的内部可以定义若干方法

在OOP的术语中，我们把`Person`称为超类（super class），父类（parent class），基类（base class），把`Student`称为子类（subclass），扩展类（extended class）。

继承树

向上转型

向下转型

super

protect

### 2.对象

new操作会调用类的构造函数，且构造函数不能像其他方法调用，只能使用new关键词。

声明**Declaration**=类型+变量名/对象名

实例化**Instantiation**=new +类，新建对象。调用无参构造函数

初始化**Initialization**=new +类（值），赋初值，调用含参构造函数

使用对象引用来调用对象的方法

new返回的值来访问新对象的字段，随即丢失新对象的引用，int a =new 类名.字段；也可以访问引用对象的方法

对象引用来调用对象的方法 类名.方法名(参数列表)；

`new`运算符返回的引用不必分配给变量。也可以直接在表达式中使用

### 3.继承

extends

一个子类只能继承一个父类（超类），父类可以有很多子类。

instanceof检查对象的类类型

### 4.接口

implements实现

interface接口

一个类可以实现多个接口。

在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。

如果一个抽象类没有字段，所有方法全部都是抽象方法：

```
abstract class Person {
    public abstract void run();
    public abstract String getName();
}
```

就可以把该抽象类改写为接口：`interface`。

所谓`interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有

因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字

在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`

Java的接口特指`interface`的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。

抽象类和接口的对比如下：

|            | abstract class       | interface                   |
| :--------- | :------------------- | :-------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

一个`interface`可以继承自另一个`interface`。`interface`继承自`interface`使用`extends`，它相当于扩展了接口的方法。

实现类可以不必覆写`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

`default`方法和抽象类的普通方法是有所不同的。因为`interface`没有字段，`default`方法无法访问字段，而抽象类的普通方法可以访问实例字段。

Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；

接口也是数据类型，适用于向上转型和向下转型；

接口的所有方法都是抽象方法，接口不能定义实例字段；

接口可以定义`default`方法

### 5.修饰符-访问控制

public可以从所有类直接访问该字段。：所有类

private字段只能在本类中直接访问，父类、子类、其它同包或不同包的类都不能直接访问。可以通过公用方法间接访问。；本类

protected同一个包中的类及所有在或不在一个包中的子类；同包+子类

默认访问可以在同一个包中任何类访问：同包

final

### 6.垃圾回收机制

内存自动管理

### 7.this关键字

`this`是对*当前对象*的引用，可用在当前对象将被调用其方法或构造函数

类方法**不能直接**访问实例变量或实例方法，它们必须使用对象引用。同样，类方法不能使用`this`关键字，因为没有实例可供`this`引用。

### 8.泛型

### 9.var关键字

省略变量类型使用var代替，编译器会在后期替换回原来变量类型

```
StringBuilder sb = new StringBuilder();
```

```
var sb = new StringBuilder();
```

### 10.字符串连接

```java
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "world";
        String s = s1 + " " + s2 + "!";
        System.out.println(s);
    }
}
```

会将其他数据类型先自动转型为字符串



```
javac --source 13 --enable-preview Main.java
```

### 11.传参（方法的参数绑定）

### 12.构造方法

即子类*不会继承*任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的

默认构造函数将调用超类的无参数构造函数 

### 13.多态

在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）

Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是`Override`。

方法名相同，方法参数相同，但方法返回值不同，也是不同的方法

那么，一个实际类型为`Student`，引用类型为`Person`的变量，调用其`run()`方法，调用的是`Person`还是`Student`的`run()`方法？

运行一下上面的代码就可以知道，实际上调用的方法是`Student`的`run()`方法。因此可得出结论：

Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic

多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法

多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码

因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：

- `toString()`：把instance输出为`String`；
- `equals()`：判断两个instance是否逻辑相等；
- `hashCode()`：计算一个instance的哈希值。
- 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用
- 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`：
- 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：
- 对于一个类的实例字段，同样可以用`final`修饰。用`final`修饰的字段在初始化后不能被修改。
- 可以在构造方法中初始化final字段：

@Override是伪代码,表示重写。(当然不写@Override也可以)，不过写上有如下好处: 
1、可以当注释用,方便阅读；
2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。

举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。
@Override
public void onCreate(Bundle savedInstanceState)

{…….}
这种写法是正确的，如果你写成：

@Override
public void oncreate(Bundle savedInstanceState)
{…….}
编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。

而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate

### 14.抽象类

如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：

把一个方法声明为`abstract`，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，`Person`类也无法被实例化。编译器会告诉我们，无法编译`Person`类，因为它包含抽象方法。

必须把`Person`类本身也声明为`abstract`，才能正确编译它：

如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰

因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。

使用`abstract`修饰的类就是抽象类。我们无法实例化一个抽象类：

因为抽象类本身被设计成只能用于被继承，抽象类可以强迫子类实现其定义的抽象方法，抽象方法实际上相当于定义了“规范”

可以通过抽象类`Person`类型去引用具体的子类的实例

引用抽象类的好处在于，我们对其进行方法调用，并不关心`Person`类型变量的具体子类型：

这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

面向抽象编程的本质就是：

- 上层代码只定义规范（例如：`abstract class Person`）；
- 不需要子类就可以实现业务逻辑（正常编译）；
- 具体的业务逻辑由不同的子类实现，调用者并不关心。

- 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；
- 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；
- 如果不实现抽象方法，则该子类仍是一个抽象类；
- 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。

### 15.静态字段与静态方法

对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：

虽然实例可以访问静态字段，但是它们指向的其实都是`Person class`的静态字段。所以，所有实例共享一个静态字段。不建议这样做，因为并不能明确表明它们是类变量

因此，不推荐用`实例变量.静态字段`去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为`类名.静态字段`来访问静态对象。

推荐用类名来访问静态字段。可以把静态字段理解为描述`class`本身的字段（非实例字段）。

有静态字段，就有静态方法。用`static`修饰的方法称为静态方法。

调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。可以使用对象引用来引用静态方法

静态方法属于`class`而不属于实例

静态方法内部，无法访问`this`变量，也无法访问实例字段，它只能访问静态字段。

因为`interface`是一个纯抽象类，所以它不能定义实例字段。但是，`interface`是可以有静态字段的，并且静态字段必须为`final`类型：

- 静态字段属于所有实例“共享”的字段，实际上是属于`class`的字段；
- 调用静态方法不需要实例，无法访问`this`，但可以访问静态字段和其他静态方法；
- 静态方法常用于工具类和辅助方法。

包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。

静态成员会在加载类时初始化，在内存创建，而非静态成员则是在创建实例时初始化，在内存创建。所以没有实例的情况下也可以访问静态成员，只要加载了所在的类。

### 16.包

Java定义了一种名字空间，称之为包：`package`。一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`。

在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。

包可以是多层结构，用`.`隔开。例如：`java.util`。

Java文件对应的目录层次要和包的层次一致

import

Java编译器最终编译出的`.class`文件只使用*完整类名*，因此，在代码中，当编译器遇到一个`class`名称时：

- 如果是完整类名，就直接根据完整类名查找这个`class`；
- 如果是简单类名，按下面的顺序依次查找：
  - 查找当前`package`是否存在这个`class`；
  - 查找`import`的包是否包含这个`class`；
  - 查找`java.lang`包是否包含这个`class`。

Java内建的`package`机制是为了避免`class`命名冲突；

JDK的核心类使用`java.lang`包，编译器会自动导入；

JDK的其它常用类定义在`java.util.*`，`java.math.*`，`java.text.*`，……；

包名推荐使用倒置的域名，例如`org.apache`。

因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功。



### 17.作用域

### 18.模块

，jar只是用于存放class的容器，它并不关心class之间的依赖

从Java 9开始引入的模块，主要是为了解决“依赖”这个问题,如果`a.jar`必须依赖另一个`b.jar`才能运行，那我们应该给`a.jar`加点说明啥的，让程序在编译和运行的时候能自动定位到`b.jar`，这种自带“依赖关系”的class容器就是模块。

依赖关系已经被写入到模块内的`module-info.class`文件



### 19.classpath和jar

### 20.方法重载

方法名相同，方法参数不同

### 21.嵌套类

嵌套类是在另一个类中定义一个类，这样的类称为嵌套类。

四种嵌套类：静态成员类（static）、非静态成员类（内部类）、匿名类、局部类

匿名类是没有名称并同时声明的类

非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有的也是如此。静态嵌套类无权访问封闭类的其他成员

### 22.注解

@Override



## 四、java中阶

### 1.字符串和编码

string是一个引用类型，也是一个class



### 2.stringbuilder

### 3.stringjoiner

### 4.包装类型

### 5.javabean

### 6.枚举类型



### 7.biginteger

### 8.bigdecimal

### 9.常用工具类型

## 五、java高级

java异常

捕获异常

try{

}catch(){

}

抛出异常

