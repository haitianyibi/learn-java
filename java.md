[TOC]

# java简介

c语言、c++语言都是**编译**成二进制文件，由计算机直接执行，称编译型语言。python、ruby等解释型语言由解释器直接加载源码然后运行，而java将源码编译成.class字节码，类似于抽象的CPU指令，针对不同平台编写虚拟机，虚拟机加载字节码并执行，形成一次编写处处运行的效果。

java EE \java SE\java ME即企业版、标准版、micro版

JSR规范\JCP组织\RI参考现实\TCK兼容性测试套件

IDE是集成开发环境：Integrated Development Environment 

三大特征：

* 封装
* 多态
* 继承

# 一、java环境设置

### 1.下载安装JavaJDK

<https://www.oracle.com/technetwork/java/javase/downloads/jdk13-downloads-5672538.html>

jdk是开发工具

jre仅是运行环境

### 2.设置环境变量

JAVA_HOME指向JDK安装目录

classpath指向默认字节码位置，当前位置"."

PATH指向JDK安装目录下的bin目录%JAVA_HOME%\bin;

bin目录下的工具:

* java：即 JVM
* javac：java编译器将.java源文件转化为.class字节码文件
* jar：用于把一类的.class文件打包成一个.jar文件
* jdb：java调试器，用于开发阶段的运行调试

### 3.第一个java程序

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

一个公开的类叫hello,大小敏感，{}里是类的定义，一个公开的静态方法叫main，()里为方法参数，参数类型String[],参数名args，返回类型为void即空，每行代码；分号结束System类的.out方法的.println方法传入参数“hello，world!”。

一个java源码只能定义一个public类型的class,并且class名要和文件名完全一致。


java文件中有多个类，且没有public类，那么文件名任意，编译的.class文件也对应有多个（JDK8）


main方法是java程序的入口，总是从main方法开始执行代码。

java缩进不是必须的

保存文件名必须和public类名相同，大小写敏感，文件类型.java

```javac  类名.java```

编译，在当前文件夹下生成.class文件

```java 类名```

运行，不需要文件类型后缀

或直接

```java 类名.java```

JVM会自动编译并运行文件

这是Java 11新增的一个功能，它可以直接运行一个单文件源码！

需要注意的是，在实际项目中，单个不依赖第三方库的Java源码是非常罕见的，所以，绝大多数情况下，我们无法直接运行一个Java源码文件，原因是它需要依赖其他的库。

![image-20200103212014828](Java.assets/image-20200103212014828.png)

[出现编码GBK不可映射字符](https://jingyan.baidu.com/article/e3c78d649a56233c4c85f502.html)

因为代码中含有中文，包括注释，系统默认编码格式GBK，中文字符代码格式UNICODE或UTF-8

notepad++编译器具有自动转码功能。

为文件指定编码格式

javac -encoding UTF-8 类名.java

[出现需要class,interface、enum](https://blog.csdn.net/a66731167/article/details/81286537)

![image-20200103212127750](Java.assets/image-20200103212127750.png)

重新保存文件，编码格式改为ANSI

# 二、面向对象的编程概念

## 1.什么是对象Object

对象是具有相关状态和行为的软件包。将对象的状态存储在字段（变量）中，通过方法（函数）公开其行为。方法在对象内部状态上运行，并用作对象间通信的主要机制，隐藏内部状态并要求通过对象的方法执行所有交互称为数据封装-面向对象编程的基本原理。

面向对象的优点：

* 模块化：可以独立于其他对象源代码编写和维护对象的源代码，创建对象后，可以轻松在系统内部传递对象
* 信息隐藏：仅通过与对象的方法进行交互，其内部实现的细节对外界隐藏
* 代码重用：如果某个对象已经存在，则在程序中可以使用该对象，可以是其他人员编写的对象。
* 可插拔性和调试简便性：如果发现对象出错，只需删除该对象代码，插入另一个对象作为替换对象即可

## 2.什么是类Class

类是从中创建对象的蓝图或原型

## 3.什么是继承Inheritance

继承为组织和构造软件提供了强大而自然的机制，不同种类的对象有一定的相同点，面向对象的编程允许类从其他类继承常用的状态和行为。

创建子类在类声明的开头使用extends关键字，后跟继承的类的名称，可以使子类代码易读，但是必须记录超类的状态和行为，超类的代码不会出现在子类的源文件中。

## 4.什么是接口Interface

接口是类与外界之间的契约，当一个类实现一个接口时，承诺提供该接口的发布行为。对象通过其公开的方法定义了与外界的交互，方法形成对象与外界的接口，接口是一组具有空主体的相关方法。实现一个接口可时类对其承诺提供的方法变得更加正式。接口在类和外部之间形成契约，该契约在编译时由编译器强制执行，如果类要实现一个接口，在成功编译该类前，该接口定义的所有方法必须出现在其源代码中。接口中的方法默认都是public和abstract的。所以在实现接口的类中，实现方法时都要在方法前加上“public”修饰符。

## 5.什么是包Package

包是用于以逻辑方式组织类和接口的命名空间，将代码放入包中使程序有利于管理。

### 1.Java的注释

* 单行注释（可以用于查找错误）

//

* 多行注释（不可以嵌套使用）

/*



*/

* JavaDoc注释方式（以/**开头,写在类和方法定义处，用于自动创建文档）

/**

*@author haitianyibi

*@version 1.0

*/

javadoc可以添加标签

@author、@deprecated、@param、@see、@since、@return

javadoc -d 文件夹名称 -author -version HelloWorld.java



### 2.标识符

* 用户可以起名的标识，如类名，变量名、方法名、接口名、包名

* 英文字母、$美元符号、_下划线开头，加上数字可以作为标识符的元素，但是数字不能作为标识符开头

* 区分大小写、无限长度的unicode编码，使用完整的单词，而不要使用隐含的缩写

* java关键字、保留字即不能用作标识符，类名、接口名使用驼峰式写法，普通变量和方法名使用小驼峰式写法、常量全大写、包名字母都小写（建议规范：命名不遵守规范编译可以通过）

* 必须先声明变量后使用，有垃圾回收机制。

四种变量分类：

1.实例变量(非静态字段)

实例变量的值对于每一个实例都是唯一的。

2.类变量(静态字段static)

无论实例化多少次，都存在一个副本应用于所有对象。，添加final修饰符将无法修改。

3.局部变量

变量位于方法体的左大括号和右大括号之间，仅对于声明他们的方法可见。

4.参数

方法的小括号之间。*参数*是指方法声明中的变量列表

### 3.关键字与保留字

* Java使用关键字标识功能，产生语法语义。  

* 关键字不做变量名、类名、方法名。

* 关键字中所有字母都是小写。

关键字keyword：

**abstract	class extends	implement	null	strictfp	true	assert	const		false	import	package	super	 try	boolean	continue	final	instanceof	private	switch	void	break	default	finally	int	protected	synchronized	volatile	byte	do	float	interface	public	this	while	case	double	for	long	return	throw	catch	else	goto	native	short	throws	char	enum	if	new	static	transient**

保留字reservedword：

**goto	const**

数据类型：class	interface	enum	byte	short	int	long	float	double	char	boolean	void

流程控制：if	else	switch	case	default	while	do	for	break	continue	return

访问权限修饰符：private	protected	public

类、变量、方法修饰符：abstract	final	static	synchronized

类与类关系：extends	implements

实例、引用、判断实例：new	this	super	instanceof

异常处理：try	catch	finally	throw	throws

包：package	import

其他修饰符：native	strictfp	transient	volatile	assert

数据类型值字面值：true	false	null

### 4.字面值!= （常量）

类似c语言中的字符常量。  1、a、屏幕、3.14。

定义变量时使用final修饰符，编译器就将该变量看做常量，后面尝试修改此常量值编译器会报错

常量名习惯全部大写。





### 5.变量

变量本质上是内存的一块空间，还具有可见性/生存周期。变量包含数据类型、名称、字面值。  

所有变量必须具有类型。

java变量分两种，基本类型变量+引用类型变量

要求首字母小写，后面每个字母首字母大写  (小驼峰写法)

变量的类型决定了变量可能的取值范围和可能执行的操作。

编译器会赋初值，但是不会为局部变量赋初始值。

变量声明：int a;int b,c;  

变量同时声明和赋值即定义:int a=1;

字面值的数据类型要和变量的数据类型一致。  

变量的值可以修改多次。而变量的空间大小的不变的，空间位置改变，即修改了引用的指针。  

 变量需要赋值才能使用，声明变量本质只是生成了引用标签，空间未申请，赋值后才实际申请了空间。

变量作用域最小化{}，减少重名变量。

给变量赋值时jvm给新值一个空间并将变量标签重新指向新变量空间，不是将旧变量空间替换值。

允许创建赋值链

允许动态初始化

成员变量和成员方法

方法局部变量：在方法体内定义的变量或方法参数内定义的，不能使用访问修饰符，可以使用final

形参调用时赋值，方法体内局部变量可以赋初值，没有默认值

静态变量（类变量）

变量的作用域之内必须唯一，不同作用域可以有相同变量名

定义创建了变量，并为其分配内存；声明没有分配内存。

一个变量在一定的区域内只能被定义一次，却可以被多次声明。

### 6.数据类型

基本数据类型是CPU可以直接进行运算的类型：

* 整数型byte、short、int、long
* 浮点类型float、double
* 字符类型char
* 布尔类型boolean

引用数据类型：

* 类class
* 接口interface
* 数组
* srting

枚举类型

不同数据类型可以指示编译器申请空间和限制变量的类型。  

`_`数字文字中数字之间的任何位置都可以出现任意数量的下划线字符。

#### 进制

2进制

8进制

10进制

16进制

#### byte

 大小8bit，即一个字节，范围-128~127

byte是有符号的8位类型-128~127



#### short

两个字节

short是有符号的16位类型-32768~32767

错误short=short+2

正确：short+=2

#### int

int是有符号的 32位类型，byte和short在表达式中时自动转化为int

交换两个数

* 临时变量法
* 加减法
* 异或法（位运算法）

a=a+b

b=a-b

a=a-b



a=a^b

b=a^b

a=a^b

#### long

long是有符号64位，1l、1L

不添加l认为是int型自动类型转换为long

#### float 

定义类型字面值需要后缀，否则出错



字面值正确写法：float32位宽1.4E5F、2e3f

字面值错误写法：

不写f会认为double类型，不能自动转化为float类型

科学计数法：

#### double

double64位宽，



#### char

char为16位0~65536，单引号，可以和整数类型运算

错误''

正确‘ ’

#### boolean

布尔类型的true和false不等于1和0

八进制010

十六进制0x10



浮点类型支持科学计数法

双值常数，支持+00正无穷 -00负无穷 +0.0 -0.0	NaN

java使用unicode表示字符 \u5465

#### 自动类型转换（自动类型提升）

不包含boolean类型的基本类型之间的运算

小范围向大范围类型自动转换，范围大的类型空间不一定大。

byte,short,char>int>long>float>double

char与short运算结果为int类型

char与byte运算结果为int类型

byte与short运算结果为int类型

char\byte\short相互运算或自己运算都使用int类型,整型常量默认类型int,浮点型默认类型double

#### 强制类型转换

大范围向小范围强制转换，可能会丢失高位数据，（截断）

在运算式子前使用**（类型）式子**进行转换

损失精度

#### string

string可以和八种数据类型只能做连接运算 +



### 7.运算符的优先级

后缀：a++、a--

一元元算符：++a、--a、+a、-a、~取反、！非

乘法：*、/、%

加法：+、-

移位：<<、>>、>>>

关系：<、>、<=、>=、instanceof

相等：==、！=

按位与：&

按位异或：^

按位或：|

逻辑与：&& 

逻辑或：||

三元：表达式?表达式1:表达式2（可以嵌套）

分配：=、+=、-=、*=、/=、%=、&=、^=、|=、<<=、>>=、>>>=

算术运算符的操作数必须是数字类型，也可以对char类型使用，但是不可以对boolean类型使用

算术运算符、布尔逻辑运算符、关系运算符、三元运算符、按位运算符

Java三元运算符基本上是简单的if语句的简写形式。



### 8.表达式

由变量、运算符和方法的调用，计算结果为单值。

语句：表达式语句、赋值语句、增量语句、方法调用语句、对象创建语句、声明语句、控制流语句。

###  9.数组 

* 基本类型数组
* 引用类型数组

### 10.输入和输出

import 导入java.util.Scanner类

* print()
* println()
* printf()+占位符
* Scanner scanner =new Scanner(System.in)创建scanner对象
* scanner.nextLine()读取一行输入获取字符串
* scanner.nextInt()读取一行输入获取整数

### 11.if判断

if(条件trun则执行){

}

if(){

}else if(){

}

if(){

}else

dosomething

### 12.switch多重选择

### 13.while循环

while(条件){

}

do{

}while(条件);



### 14.for循环

for(初始;条件;变化){

}

允许多个变量控制循环for(int i=0,j=n;i<j;i++,j--){

}

初始，变化可以为空，条件不能空for(;!aboolean;){}

for循环可以嵌套

Java for each循环对序列元素迭代，不使用循环计数器

for(String s:arr){//arr为string数组、类型要与数组类型兼容

}

for(int a[]:arr){//arr为二维数组

}



### 15.break和continue

break；循环终止，多重循环时只会终止内层循环

switch分支的break会跳出switch语句。分支终止

continue完成这次循环，内层

continue可以使用标签lable

lable名:语句

continue lable名；



### 16.转义字符

\\'	\\"	\\\	\r	\f	\t	\b	\n

八进制\123	十六进制unicode字符\u061

### 17.枚举

​        Weekday day = Weekday.SUN;

enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}

`enum`定义的类型就是`class`，只不过它有以下几个特点：

- 定义的`enum`类型总是继承自`java.lang.Enum`，且无法被继承；
- 只能定义出`enum`的实例，而无法通过`new`操作符创建`enum`的实例；
- 定义的每个实例都是引用类型的唯一实例；
- 可以将`enum`类型用于`switch`语句。

# 三、java语言基础Language Basics

## 1.变量Variables

对象状态存储在字段当中，对象行为存储在方法当中。

java编程语言定义了以下种类的变量：

* **实例变量**（非静态字段）从技术上讲，对象将其各自的状态存储在非静态字段中，即声明为不使用static关键字的字段，非静态字段也称为实例变量，因为实例变量的值对于每个类的每个实例（对象）都是唯一的。
* **类变量**（静态字段）是由*static*修饰的变量，无论该变量实例化了多少次，该变量存在一个副本。
* **局部变量**与对象在字段中存状态相似，方法将临时状态存储在局部变量中。声明局部变量的语法类似于声明字段，没有特殊的关键字将变量指定为局部变量，该确定完全来自声明变量的位置，该位置在方法的左括号和右括号之间。因此局部变量仅对声明它们的方法可见，在类中的其他方法或变量无法访问它们。大括号
* **参数**是为方法提供额外信息的变量，被分类为变量而不是字段，在方法签名的参数列表中。小括号

java编程语言**变量**的命名规则和约定：

* 变量名称区分大小写，变量的名称可以是任何合法的标识符-无限长度的*unicode*字母和数字序列，以字母、美元符号￥、下划线\_开头。但是约定变量名始终以字母开头，而不是美元符号￥或下划线\_字符，惯例完全不使用美元符号￥，不允许使用空格。
* 后续字符可以是字母、数字，美元符号￥下划线_字符。为变量选择名称时，应使用完整的单词而不使用隐晦的缩写。
* 仅含一个单词的变量名应全部小写，包含多个单词的变量名首单词小写后续大写每个单词的第一个字母（**小驼峰写法**），如果变量是常量则将每个字母大写并用下划线分隔后续单词。

### 基本数据类型Primitive Data Types

java编程语言是静态类型的，必须先声明所有变量后使用。变量的数据类型决定了字段值的范围以及可能的操作。java有八种基本数据类型，由语言预先定义并由由关键字命名，基本值不与其它基本值共享状态。基本数据类型是CPU可以直接进行运算的类型。八种基本数据类型是：

* **byte**:byte数据类型是8位带符号的二进制补码整数，最小值为-128，最大值为127。
* **short**:short数据类型是16位带符号的二进制补码整数。最小值为-32768，最大值为32767。
* **int**:int数据类型默认情况下是32位带符号的二进制补码整数。可以使用Integer类静态方法compareUnsigned、divideUnsigned等将int数据类型表示无符号的32位整数进行运算。
* **long**:long数据类型是64位二进制补码整数。可以使用Long类静态方法compareUnsigned、divideUnsigned等将int数据类型表示无符号的64位整数进行运算。
* **float**:float数据类型是单精度32位IEEE 754浮点数。
* **double**:double数据类型是双精度64位IEEE 754浮点数。
* **boolean**:boolean数据类型只有两个可能的值：true和false。
* **char**:chart​数据类型是单个16位Unicode字符。最小值为\u0000即0，最大值为\uffff 65535

在java.lang.String类为字符串提供特殊支持，用双引号扩住字符串会自动创建一个新String对象，String对象是不可变的，意味着对象一旦创建就无法更改，该类不是基本数据类型。

### 字面值Literals

初始化基本数据类型的变量未使用*new*关键字，基本数据类型是语言中内置的特殊数据类型，基本数据类型不是从类中创建的对象。字面值是固定值的源代码表示，直接在代码中表示，无需计算，可以将字面值分配给基本数据类型。

boolean result = **true**;	byte b = **100**;	char c = **'c'**;	int hexVal = **0x1a**;	 int binVal = **0b11010**;	

double d2 = **1.234e2**;(科学计数法)	float f1  = **123.4f**;

* 二进制字面值：前缀 0b 表示二进制数

* 十六进制字面值：前缀 0x 表示十六进制数

* 整数字面值：整数字面量末尾带L或 l 则为long型字面量，否则为int型字面量，建议使用大写L（l与1相似）。整数类型byte、short、int、long赋值可以用int字面值，long类型超过int的范围的值可以用long字面值。整数字面值可以使用二进制Binary、十进制Decimal和十六进制Hexadecimal

* 浮点字面值：浮点字面值以F或f作后缀，否则为double类型，并且可以选择D或d结尾。

* 字符char和字符串String字面值：字符和字符串可以使用任何Unicode字符，包括Unicode转义字符，char字面值使用单引号‘ ’，String字面值使用双引号“ ”。

如果含许多数字可以使用下划线_分隔数字以分组，提高代码的可读性

正确使用只能在数字之间分隔：

long number = 1234_5678_9012_3456L;

float pi =  3.14_15F;

long hex = 0xFF_EC_DE_5E;

byte b= 0b0010_0101;

int x = 5_______2;

int x= 0x5_2; 


错误使用：

* 在数字的开头或结尾：int x = 52_;   int x= 0x_52;      int x = 0_x52;      int x = 0x52_;
* 与浮点小数点相邻：float pi = 3_.1415F;   float pi = 3._1415F;   
* 在F或f之前：long x = 999_99_9999_L;
* 在字符串的数字当中需要连续的数字时：String x = "123_465"

### 常量constant value

int MAX_X =100;需要的值是基本不会变，变量名使用全大写，用下划线分隔每个字母，可以使用final保证值不变。 

### 默认值Default Values

声明字段时，不一定总是需要分配值，编译器会将已声明但未初始化的字段设置合理的默认值。一般来说默认值将为零或null

**byte:0	short:0	int:0	long:0L	float:0.0f	double:0.0d	char:'\u0000'	String(or any object):null	boolean:false**

编译器不会将默认值分配给未初始化的局部变量，访问未初始化的局部变量将导致编译时错误。

### 数组Arrays

 数组是单一类型的值的固定数量的容器对象。数组类型 **type []**和数组名，创建数组时确定数组的长度n，创建之后数组长度不可变。数组的元素通过数组下标引用 ，从0开始到n-1。声明数组并不创建数组，只是告诉编译器该变量将保存指定类型的数组。中括号[]也可以放在数组名后面声明，但是不建议。

声明整型数组： int [] anArray; 

分配数组相应的内存空间：   anArray = new int [10];  或  int [] anArray = {1,2,5,9};  使用逗号隔开元素 

多维数组：String  \[]\[] names  = {  {"abc","def"},{"gh","ij"},{"k"}  }

使用**数组名.length**确定数组长度。

复制数组使用System.arraycopy(copyfrom,posfrom,copyto,posto,length)

或者type [] arr=java.util.Arrays.copyOfRange(copyfrom,start,end)

## 2.运算符Operators

运算符是特殊的符合，可对一个两个或三个操作数执行运算并返回结果，下表运算符按优先级顺序排出，优先级越高越靠近顶部，同一行优先级相同，除了赋值运算符**=**之外所有二元运算符从左向右求值，赋值运算符从右向左求值，三元运算符只有**？=**从左向右运算。

|                            运算符 | 优先顺序                                            |
| --------------------------------: | :-------------------------------------------------- |
|                 后缀运算符postfix | `expr++  expr--`                                    |
| 一元运算符unary，前缀运算符profix | `++expr  --expr  +expr  -expr  ~  !`                |
|                乘法multiplicative | `*  /  %`                                           |
|                      加法additive | `+  -`                                              |
|                         位移shift | `<<  >>  >>>`                                       |
|                    关系relational | `< >  <=  >=  instanceof`                           |
|                      相等equality | `== !=`                                             |
|                 按位与bitwise AND | `&`                                                 |
|      按位异或bitwise exclusive OR | ^                                                   |
|        按位或bitwise inclusive OR | `|`                                                 |
|                 逻辑与logical AND | `&&`                                                |
|                  逻辑或logical OR | `||`                                                |
|                 三元运算符ternary | `? :`                                               |
|                    分配assignment | `=  +=  -=  *=  /=  %=  &=  ^=  |=  <<=  >>=  >>>=` |



### 赋值、算术和一元运算符

* 赋值运算符：**=**将右边的式子结果赋值给左边的变量。 还可以用于对象的引用赋值给实例化对象

* 算术运算符 ：**+  -  *  /  %**，其中+还可以做字符串的连接
* 一元运算符：正**+**， 负**-**，自增**++**，自减**--**，逻辑非**！**，

### 相等、关系和条件运算符

* 相等、关系运算符：等于**==**、不等于 **!=**、大于**>**、大于或等于 **>=**、小于**<**、小于或等于 **<=**

* 条件运算符：短路与 **&& **、短路或 **||**，加上三元运算符**？：**在进行布尔表达式运算时具有短路行为。 

* 类型比较运算符：instanceof运算符将特定类型和对象进行比较，可以比较对象是否是实现特定接口的类的实例，子类的实例还是类的实例。

### 按位和移位运算符

* 一元补码运算符：**~**，将二进制的0和1转换。
* 有符号的位移运算符：左移运算符   **<<**   右移运算符  **>>**，被位移数在运算符左侧，位移量在右侧给出称右操作数，必须是非负值，左移空出用0填补，右移高位补符号位，高位左移舍弃高位，低位右移舍弃低位，符号位不参与位移。无符号位移运算符**>>>**低位舍弃高位补0
* 按位与运算符：**&**
* 按位或运算符：**|**
* 按位异或运算符：**^**

## 3.表达式、语句和块Expressions, Statements, and Blocks

运算符可以构建表达式，表达式可以计算值，表达式是语句的核心组成部分，多个语句可以组合分为一个或多个块。

* 表达式：表达式的结果为单个值，值的类型取决于表达式中使用的元素。表达式可以复合嵌套，只要满足返回类型是需要的类型即可。可分为赋值表达式、自增自减表达式、方法调用、对象创建表达式。如：a++、add(a,b)、new String、a=10
* 语句：一条语句构成完整的执行单元，以分号**；**结束语句。使用表达式的语句称为表达式语句，还有声明语句和控制流语句。如：double aValue；
* 块：块是一组大括号braces 之间零或多条语句构造的语句集合



## 4.控制流语句Control Flow Statements

源文件中的语句通常按显示顺序从上到下执行，控制流语句通过决策、循环和分支来分解执行流，使有条件的执行代码

#### if-then和if-then-else语句

if条件判断语句只有在条件判断为true时才执行if语句块，如果条件判断为false则执行下一个语句块。if判断语句对应的只有一条执行语句时可以省略一对大括号{}，但是会降低易读性，多条执行语句不可以省略大括号{}。

if(条件判断){

执行语句块

}



if(条件判断){

执行语句块1

}else {

执行语句块2

}

可以设置多层条件判断：

if(条件判断1){

执行语句块1

}else if(条件判断2){

执行语句块2

}else {

执行语句块3

}

#### switch语句



#### while和do-while语句

#### for语句

#### 分支语句break、continue、return

### 1.类

class本身就是一种数据类型

类主体用{}括起即类的定义，类变量、实例变量、方法、构造函数

大驼峰写法

构造函数，类似方法声明，但必须使用本类名且无返回类型

构造函数可以有多个，但是参数列表（参数的数量和类型）不能相同，

编译器会自动为没有构造函数的类提供无参的默认构造函数，默认构造函数将调用超类的无参构造函数，若超类没有无参构造函数编译器将报错，

构造函数可以使用访问修饰符

构造方法重载

方法首字母为动词，小驼峰写法。有返回类型

调用方法overload时，使用的参数必须在类型和顺序上与声明的参数匹配。

方法重载，区别方法的不同不依靠方法名，依靠参数（参数个数、类型、顺序），在同一类中，功能相似时方法名可以相同，功能不同时方法名尽可能不同。方法不能重复。方法重载和方法名和参数有关，和返回类型、修饰符无关。

可以使用任何数据类型作为方法和构造函数的参数，包括原始数据类型和引用数据类型（数组，对象）。参数数量可以无限，当不确定使用多少参数时可以使用*varargs*的构造方式，在最后的参数类型上加上...三个点和参数名，就可以使用该参数0个到无限个。方法内部将该参数视为数组，用数组下标调用传入的参数。

方法返回到调用它时的代码

- 完成方法中的所有语句，
- 达到`return`声明，或
- 引发异常（稍后会发现），

以先发生者为准。

如果尝试从声明的方法返回值`void`，则会出现编译器错误。

返回值的数据类型必须与方法声明的返回类型相匹配

java是面向对象的语言，一个程序的基本单位是class

在类的内部可以定义若干方法

在OOP的术语中，我们把`Person`称为超类（super class），父类（parent class），基类（base class），把`Student`称为子类（subclass），扩展类（extended class）。

继承树

向上转型

向下转型

super

protect

* 行尾风格

a{

}

* 次行风格

a

{

}



### 2.对象

new操作会调用类的构造函数，且构造函数不能像其他方法调用，只能使用new关键词。

声明**Declaration**=类型+变量名/对象名

实例化**Instantiation**=new +类，新建对象。调用无参构造函数

初始化**Initialization**=new +类（值），赋初值，调用含参构造函数

使用对象引用来调用对象的方法

new返回的值来访问新对象的字段，随即丢失新对象的引用，int a =new 类名.字段；也可以访问引用对象的方法

对象引用来调用对象的方法 类名.方法名(参数列表)；

`new`运算符返回的引用不必分配给变量。也可以直接在表达式中使用

### 3.继承

extends

一个子类只能继承一个父类（超类），父类可以有很多子类。

instanceof检查对象的类类型

### 4.接口

implements实现

interface接口

一个类可以实现多个接口。

在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。

如果一个抽象类没有字段，所有方法全部都是抽象方法：

```
abstract class Person {
    public abstract void run();
    public abstract String getName();
}
```

就可以把该抽象类改写为接口：`interface`。

所谓`interface`，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有

因为接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。

当一个具体的`class`去实现一个`interface`时，需要使用`implements`关键字

在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`

Java的接口特指`interface`的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。

抽象类和接口的对比如下：

|            | abstract class       | interface                   |
| :--------- | :------------------- | :-------------------------- |
| 继承       | 只能extends一个class | 可以implements多个interface |
| 字段       | 可以定义实例字段     | 不能定义实例字段            |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法            |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法         |

一个`interface`可以继承自另一个`interface`。`interface`继承自`interface`使用`extends`，它相当于扩展了接口的方法。

实现类可以不必覆写`default`方法。`default`方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。

`default`方法和抽象类的普通方法是有所不同的。因为`interface`没有字段，`default`方法无法访问字段，而抽象类的普通方法可以访问实例字段。

Java的接口（interface）定义了纯抽象规范，一个类可以实现多个接口；

接口也是数据类型，适用于向上转型和向下转型；

接口的所有方法都是抽象方法，接口不能定义实例字段；

接口可以定义`default`方法

### 5.修饰符-访问控制

public可以从所有类直接访问该字段。：所有类

private字段只能在本类中直接访问，父类、子类、其它同包或不同包的类都不能直接访问。可以通过公用方法间接访问。；本类

protected同一个包中的类及所有在或不在一个包中的子类；同包+子类

默认访问可以在同一个包中任何类访问：同包

final

### 6.垃圾回收机制

内存自动管理

### 7.this关键字

`this`是对*当前对象*的引用，可用在当前对象将被调用其方法或构造函数

类方法**不能直接**访问实例变量或实例方法，它们必须使用对象引用。同样，类方法不能使用`this`关键字，因为没有实例可供`this`引用。

### 8.泛型

### 9.var关键字

省略变量类型使用var代替，编译器会在后期替换回原来变量类型

```
StringBuilder sb = new StringBuilder();
```

```
var sb = new StringBuilder();
```

### 10.字符串连接

```java
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "world";
        String s = s1 + " " + s2 + "!";
        System.out.println(s);
    }
}
```

会将其他数据类型先自动转型为字符串



```
javac --source 13 --enable-preview Main.java
```

### 11.传参（方法的参数绑定）

java参数传递机制：值传递

基本数据类型传递值，引用数据类型传递地址

### 12.构造方法

即子类*不会继承*任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的

默认构造函数将调用超类的无参数构造函数 

初始化顺序：静态字段》非静态字段》构造器初始化

### 13.多态

在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）

Override和Overload不同的是，如果方法签名如果不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是`Override`。

方法名相同，方法参数相同，但方法返回值不同，也是不同的方法

那么，一个实际类型为`Student`，引用类型为`Person`的变量，调用其`run()`方法，调用的是`Person`还是`Student`的`run()`方法？

运行一下上面的代码就可以知道，实际上调用的方法是`Student`的`run()`方法。因此可得出结论：

Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。

这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic

多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法

多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码

因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：

- `toString()`：把instance输出为`String`；
- `equals()`：判断两个instance是否逻辑相等；
- `hashCode()`：计算一个instance的哈希值。
- 在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过`super`来调用
- 继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`。用`final`修饰的方法不能被`Override`：
- 如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为`final`。用`final`修饰的类不能被继承：
- 对于一个类的实例字段，同样可以用`final`修饰。用`final`修饰的字段在初始化后不能被修改。
- 可以在构造方法中初始化final字段：

@Override是伪代码,表示重写。(当然不写@Override也可以)，不过写上有如下好处: 
1、可以当注释用,方便阅读；
2、编译器可以给你验证@Override下面的方法名是否是你父类中所有的，如果没有则报错。例如，你如果没写@Override，而你下面的方法名又写错了，这时你的编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。

举例：在重写父类的onCreate时，在方法前面加上@Override 系统可以帮你检查方法的正确性。
@Override
public void onCreate(Bundle savedInstanceState)

{…….}
这种写法是正确的，如果你写成：

@Override
public void oncreate(Bundle savedInstanceState)
{…….}
编译器会报如下错误：The method oncreate(Bundle) of type HelloWorld must override or implement a supertype method，以确保你正确重写onCreate方法（因为oncreate应该为onCreate）。

而如果你不加@Override，则编译器将不会检测出错误，而是会认为你为子类定义了一个新方法：oncreate

### 14.抽象类

如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：

把一个方法声明为`abstract`，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，`Person`类也无法被实例化。编译器会告诉我们，无法编译`Person`类，因为它包含抽象方法。

必须把`Person`类本身也声明为`abstract`，才能正确编译它：

如果一个`class`定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用`abstract`修饰

因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。

使用`abstract`修饰的类就是抽象类。我们无法实例化一个抽象类：

因为抽象类本身被设计成只能用于被继承，抽象类可以强迫子类实现其定义的抽象方法，抽象方法实际上相当于定义了“规范”

可以通过抽象类`Person`类型去引用具体的子类的实例

引用抽象类的好处在于，我们对其进行方法调用，并不关心`Person`类型变量的具体子类型：

这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

面向抽象编程的本质就是：

- 上层代码只定义规范（例如：`abstract class Person`）；
- 不需要子类就可以实现业务逻辑（正常编译）；
- 具体的业务逻辑由不同的子类实现，调用者并不关心。

- 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；
- 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；
- 如果不实现抽象方法，则该子类仍是一个抽象类；
- 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。

### 15.静态字段与静态方法

对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：所有实例的静态字段都被修改了，原因是静态字段并不属于实例：

虽然实例可以访问静态字段，但是它们指向的其实都是`Person class`的静态字段。所以，所有实例共享一个静态字段。不建议这样做，因为并不能明确表明它们是类变量

因此，不推荐用`实例变量.静态字段`去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为`类名.静态字段`来访问静态对象。

推荐用类名来访问静态字段。可以把静态字段理解为描述`class`本身的字段（非实例字段）。

有静态字段，就有静态方法。用`static`修饰的方法称为静态方法。

调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法类似其它编程语言的函数。可以使用对象引用来引用静态方法

静态方法属于`class`而不属于实例

静态方法内部，无法访问`this`变量，也无法访问实例字段，它只能访问静态字段。

因为`interface`是一个纯抽象类，所以它不能定义实例字段。但是，`interface`是可以有静态字段的，并且静态字段必须为`final`类型：

- 静态字段属于所有实例“共享”的字段，实际上是属于`class`的字段；
- 调用静态方法不需要实例，无法访问`this`，但可以访问静态字段和其他静态方法；
- 静态方法常用于工具类和辅助方法。

包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。

静态成员会在加载类时初始化，在内存创建，而非静态成员则是在创建实例时初始化，在内存创建。所以没有实例的情况下也可以访问静态成员，只要加载了所在的类。

### 16.包

Java定义了一种名字空间，称之为包：`package`。一个类总是属于某个包，类名（比如`Person`）只是一个简写，真正的完整类名是`包名.类名`。

在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。

包可以是多层结构，用`.`隔开。例如：`java.util`。

Java文件对应的目录层次要和包的层次一致

import

Java编译器最终编译出的`.class`文件只使用*完整类名*，因此，在代码中，当编译器遇到一个`class`名称时：

- 如果是完整类名，就直接根据完整类名查找这个`class`；
- 如果是简单类名，按下面的顺序依次查找：
  - 查找当前`package`是否存在这个`class`；
  - 查找`import`的包是否包含这个`class`；
  - 查找`java.lang`包是否包含这个`class`。

Java内建的`package`机制是为了避免`class`命名冲突；

JDK的核心类使用`java.lang`包，编译器会自动导入；

JDK的其它常用类定义在`java.util.*`，`java.math.*`，`java.text.*`，……；

包名推荐使用倒置的域名，例如`org.apache`。

因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从`.zip`改为`.jar`，一个jar包就创建成功。



### 17.作用域

### 18.模块

，jar只是用于存放class的容器，它并不关心class之间的依赖

从Java 9开始引入的模块，主要是为了解决“依赖”这个问题,如果`a.jar`必须依赖另一个`b.jar`才能运行，那我们应该给`a.jar`加点说明啥的，让程序在编译和运行的时候能自动定位到`b.jar`，这种自带“依赖关系”的class容器就是模块。

依赖关系已经被写入到模块内的`module-info.class`文件



### 19.classpath和jar

### 20.方法重载

方法名相同，方法参数不同

### 21.嵌套类

嵌套类是在另一个类中定义一个类，这样的类称为嵌套类。

四种嵌套类：静态成员类（static）、非静态成员类（内部类）、匿名类、局部类

匿名类是没有名称并同时声明的类

非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有的也是如此。静态嵌套类无权访问封闭类的其他成员

### 22.注解

@Override

### 23.java API文档

# 四、类和对象

## 1.类

## 2.对象

### 创建对象

### 使用对象

### 从方法返回值

### this关键字

### 访问控制

### 类成员

### 初始化字段

## 3.嵌套类

### 内部类示例

### 本地类

### 匿名类

### lambda表达式

### 何时使用嵌套类、本地类、匿名类和lambda表达式

## 4.枚举类型

### 1.字符串和编码

string是一个引用类型，也是一个class

字符串常量值，不替换原来字符串

### 2.stringbuilder

### 3.stringjoiner

### 4.包装类型

### 5.javabean

javabean是一种java语言写成的可重用组件，符合：

* 类是公共的
* 有一个无参的公共构造器
* 有属性，且有对应的get、set方法



### 6.枚举类型



### 7.biginteger

### 8.bigdecimal

### 9.常用工具类型

# 五、注释

注释是元数据的一种形式，为编译器提供信息。

## 1.注释基础

## 2.声明注释类型

## 3.预定义的注释类型

## 4.类型注释和可插入类型系统

## 5.重复注释

java异常

捕获异常

try{

}catch(){

}

抛出异常

# 六、接口和继承

子类可以从超类继承字段和方法，所有的类都派生自object类，接口的实现和继承

## 1.接口

### 定义接口

### 实现接口

### 使用接口作为类型

### 不断发展的接口

### 默认方法

## 2.继承

### 状态、实现和类型的多重继承

### 覆盖和隐藏方法

### 多态性

### 隐藏字段

### 关键字super

#### 作为超类的对象

#### 编写final类和方法

#### 抽象方法和类

# 七、数字和字符串

使用Number、String对象和格式化数据输出

## 1.数字

### 数字类

### 格式化数字打印输出

### 超越基本算法

## 2.性格

## 3.弦乐

### 在数字和字符串之间转换

### 操纵字符串中的字符

### 比较字符串和部分字符串

### SrtingBuilder类

## 4.自动装箱和拆箱

# 八、泛型

泛型是java编程语言的强大功能，提高了代码的类型安全性，使编译时可以检测到更多错误

## 1.为什么要使用泛型

## 2.通用类型

### 原始类型

## 3.通用方法

## 4.有界类型参数

### 通用方法和有界类型参数

## 5.泛型、继承和子类型

## 6.类型推断

## 7.通配符

### 上界通配符

### 无限通配符

### 下界通配符

### 通配符和子类型

### 通配符捕获和帮助器方法

### 通配符使用准则

## 8.类型擦出

### 通用类型的擦除

### 通用方法的删除

### 类型消除和桥接方法的影响

### 不可修改的类型

## 9.泛型限制

# 九、包

包是java编程语言的一项功能，可帮助组织和构造类以及它们之间的关系

## 1.创建和使用包

### 创建一个包

### 包命名

### 使用包成员

### 管理源文件和类文件

### 创建和使用包的摘要